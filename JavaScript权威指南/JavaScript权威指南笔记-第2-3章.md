# JavaScript权威指南2/3章
## 第二章：词法结构
### 2.1字符集
* JS使用Unicode字符集编写，这是ASCII和Latin-1的超集
* JS区分大小写
    * 但是html不区分大小写
* JS忽略空格，换行符和格式控制符
### 2.3直接量
* 注意一下直接两可以是正则表达式直接量，比如/javascript/gi
### 2.4 标识符和保留字
* 这个特别注意下严格模式下的保留字
    * implements
    * let
    * private
    * public
    * yield
    * interface
    * package
    * protected
    * static
### 2.5 可选分号
* js会自动在【换行处 且 缺少分好就无法正确解析代码】的时候填补分号
## 第三章：类型、值和变量
### 3.1数字
* js不区分整数值和浮点数，所有的数字都用浮点数表示，采用IEEE 754标准的64位浮点格式表示数字
* 整型
    * 进制
        * 16进制：0x
        * 8进制：0
            * ES标准不支持8进制，所以尽量别用
                * 严格模式下8进制是禁止的
* 浮点型
    * 记住指数记数法就好，e/E都可以，+/-也可以用，如 6.02e-3
* 常见数学计算函数都封装在Math里
    * 幂运算
        * Math.pow(a,b)
            * 立方根
                * Math.pow(3,1/3)
    * 四舍五入
        * Math.round()
    * 向上取整
        * Math.ceil()
    * 向下取整
        * Math.floor()
    * 绝对值
        * Math.abs()
    * 返回最大值/最小值
        * Math.max() / Math.min
    * 生成一个0《x<1.0的伪随机数
        * Math.random()
    * 圆周率
        * Math.PI
    * 自然对数的底数
        * Math.E
    * 平方根
        * Math.sqrt
    * 三角函数
        * Math.sin()/Math.cos
    * 自然对数
        * Math.log()
    * e的n次幂
        * Math.exp()
* JavaScrip的算术运算在溢出/下溢/被0整除 都不会报错
    * 溢出
        * 结果为一个±infinity值，表示无穷大/小
    * 下溢
        * 无穷小属于溢出，不是属于下溢
        * 指的是运算结果无限接近0且比js能表示的最小值还小
        * 结果：返回0
    * 被0整除
        * 返回±infinity
        * 但是0/0会返回一个非数字值NaN
    * JS中的非数字值与【任何值】都不等，包括自身
        * 无法通过x==NaN 来判断x是否是NaN
        * 通过.isNaN()函数来判断
            * 类似函数还有.isFinite（）
        * 应该通过x!=x
    * -0 = +0
* 3.1.5 日期与时间
    * Date（）构造函数可以创建表示日期和时间的对象
    * undefined
### 3.2文本
* 从ES5开始，字符串直接量可以拆分成数行，每行以‘\'结束
* 常见转义字符	
    * \t 水平制表符
        * \v垂直制表符
    * \n 换行符
    * \b 退格符
    * \r 回车符
* 字符串api
    * undefined
* 模式匹配
    * 这里抽到第十章讲吧
### 3.3布尔值
* 任意Js的值都会转换为布尔值
    * 转为true
        * 一般有值就会使真值
    * 转为false
        * undefined
        * null
        * 0
        * -0
        * NaN
        * "" 空字符串
* 注意&&，||，！ 这种逻辑运算符都有C++一样的特性，就是判断了第一个，如果已经满足逻辑条件，就不会执行第二个语句
### 3.4 Null 和 undefined
* null
    * null是一个特殊的对象，含义是“非对象”，表示数字，字符串，对象是“无值”
* undefined
    * 指的是变量没有初始化，不存在，没有这个属性
* 当使用==的时候，两者相等；使用===的时候，不相等
### 3.5 全局对象
* 全局属性
    * ，比如undefined，infinity和NaN
* 全局函数
    * 比如isNaN()，parseInt()，eval（）
* 构造函数
    * 比如Date()，RegExp()
* 全局对象
    * 比如Math，JSON
* 在代码的最顶级，不在任何函数内的js代码中可以用var global = this 得到全局变量
    * 而在客户端JS，在浏览器窗口中的所有JS代码中，window对象充当了全局对象
    * window对象有一个属性window引用自身，所以可以代替this来引用全局对象
### 3.6 包装对象
* 指：存取 字符串、数字、布尔值的属性时 创建的临时对象
    * 因为字符串，数字，布尔值都是只读的，并且不能定义新属性，所以它们是有别于对象的
    * 然后包装对象被创建后，被存取之后就会销毁
        * undefined
    * ==会将原始值和包装对象认为相等，===不相等
### 3.7 不可变的原始值和可变的对象引用
* 不可更改的JS原始值
    * undefined，null，布尔值，数字，字符串
        * 特别注意，字符串也是不可以更改的，字符串中所有的方法看上去返回了一个修改后的字符串，实际上返回的是一个新的字符串值
    * 但是对象（包括数组与函数）可以
* 可变的对象引用
    * 我们通常将对象成为“引用类型” reference type ，与基本类型区分开
    * 对象的比较≠值的比较，即使两个对象包含同样的属性同样的值，在===的情况下是不会相等的
    * 对象的比较 都是 引用的比较，只有引用同一个基类对象的时候，它们才相等
    * 如何copy/比较 一个对象副本
        * 显式赋值/比较
### 3.8 类型转换
* 3.8.1 转换和相等性
    * 注意 能转化并不代表==就相等
* 3.8.2 显式类型转换
    * Boolen()
    * Number()
    * String()
    * Object()
    * 除了null和undefined之外，任何值都有toString()方法
        * Number类的对应方法，接受一个进制转换参数（默认为10）
        * 字符串转换为数字
            * Number（）构造函数，将传入的字符串转换为一个整数或者浮点数，只能基于十进制数，不能出现非法尾随字符
            * parseInt()  只解析整数
            * parseFloat() 解析整数和浮点数，可以接收第二个可选参数，制定数字转换的基数（比如八进制啊之类的
* 3.8.3 对象转换为原始值
    * 对象→布尔值
        * 所有对象都转换为true，包括数组，函数
    * 对象→字符串
        * 如果有，优先调用对象的toString（）方法，如果toString（）返回了一个JS原始值，那么就将这个值转为字符串
        * 如果没有toString()方法，或者toString（）不返回原始值
            * 调用valueOf()方法，如果返回了原始值，转换为字符串
        * 如果前面2个方法都挂了，就会抛出异常
    * 对象→数字
        * 先把对象转换为字符串，再转换为数字
    * 所以含有一个元素的数组转换成字符串的结果 =  这个元素转换为字符串的结果
    * Date类型对象特殊
    * 而在“=”，“+”，“！=”“<" 这种运算发，对象转换到原始值将……？
### 3.9 变量声明
* 声明变量后如果没有指定初始值，那么初始值将是undefined
### 3.10 变量作用域
* 声明提前（hoisting）
    * JS的函数作用域是指【函数内生命的所有变量在函数体内始终是可见的】
    * 变量在代码的声明之前就已经可用，这叫声明提前
    * 可以理解为JS函数里生命的所有变量（但不涉及赋值）都被提前到了函数体的顶部
    * 这个骚操作是在预编译的时候进行的
* 作为属性的变量
    * JS强制规定，全局变量是全局对象的属性
    * JS可以允许使用this来获得全局对象，但是没有方法引用全局变量中存放的对象
* 作用域链
    * 意思就是当JS需要查找变量值x的时候（成为变量解析 variable resolution）
    * 它会从作用域链的第一个对象可以查找，如果有x，就直接用
    * 如果没有，查找链上的下一个对象，以此类推，知道查到最顶层的那个对象
    * 59页的那段话我是没有看懂的
*XMind: ZEN - Trial Version*