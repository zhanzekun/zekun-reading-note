# 牛客商的腾讯内推实习二面（前端岗）

1. ### 判断两个链表是否相交并找出交点  

   - ##### 两个链表均不含有环

     - ##### 直接法，遍历两个链表，判断第一个链表的每个结点是否在第二个链表中

       - 时间复杂度为O(len1*len2)，耗时很大  len是长度

     - hash计数法

       - 如果两个链表相交，则两个链表就会有共同的结点；而结点地址又是结点唯一标识。因而判断两个链表中是否存在地址一致的节点，就可以知道是否相交了。
       - 可以对第一 个链表的节点地址进行hash排序，建立hash表，然后针对第二个链表的每个节点的地址查询hash表，如果它在hash表中出现，则说明两个链表有共 同的结点。这个方法的时间复杂度为：O(max(len1+len2)；但同时还得增加O(len1)的存储空间存储哈希表。这样减少了时间复杂度，增加 了存储空间

     - 先遍历第一个链表到他的尾部，然后将尾部的next指针指向第二个链表(尾部指针的next本来指向的是null)。这样两个链表就合成了一个链表，判断原来的两个链表是否相交也就转变成了判断新的链表是否有环的问题了：即**判断单链表是否有环？**

       - 如果新链表是有环的，那么原来第二个链表的头部一定在环上。因此我们就可以从第二个链表的头部进行遍历的，从而减少了时间复杂度(减少的时间复杂度是第一个链表的长度，这种方法可以判断两个链表是否相交，但不太容易找出他们的交点。![image](http://hi.csdn.net/attachment/201106/28/0_1309244135GYEy.gif)

     - 仔细研究两个链表，如果他们相交的话，那么他们最后的一个节点一定是相同的，否则是不相交的。因此判断两个链表是否相交就很简单了，分别遍历到两个链表的尾部，然后判断他们是否相同，如果相同，则相交；否则不相交。示意图如下：![image](http://hi.csdn.net/attachment/201106/28/0_1309244136MWLP.gif)

       - 判断出两个链表相交后就是判断他们的交点了。假设第一个链表长度为len1，第二个问len2，然后找出长度较长的，让长度较长的链表指针向后移动|len1 - len2| (len1-len2的绝对值)，然后在开始遍历两个链表，判断节点是否相同即可。

   - 两个链表都有环

     - 找到第一个链表的环点，然后将环断开（当然不要忘记了保存它的下一个节点），然后再来遍历第二个链表，如果发现第二个链表从有环变成了无环，那么他们就是相交的嘛，否则就是不相交的了。
       - 如果相交点在环外，那么切掉环点，问题回到变成2个无环的链表求交点
       - 如果相交点在环内，那么遍历它

   - 当一个链表中有环，一个链表中没有环时，两个链表必不相交。

2. ### 说说http，知道哪些响应码  

   - ##### HTTP，超文本传输协议

     - HTTP是无状态的，所以引入了cookie来保持状态

     - HTTP消息的结构

       - ##### **通用头部 header**

         - request Url：请求的web服务器地址
         - request method：请求方法
         - status code：请求返回的状态码
         - remote address：请求的远程服务器地址（会转为IP？）？？？？

       - ##### **请求/响应头部 http header**

         - 常用的请求头部
           - Accept: 接收类型，表示浏览器支持的MIME类型（对标服务端返回的Content-Type）
           - Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
           - Content-Type：客户端发送出去实体内容的类型
           - Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
           - If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
           - Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
           - Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
           - If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
           - Cookie: 有cookie并且同域访问时会自动带上
           - Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
           - Host：请求的服务器URL
           - Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
           - Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
           - User-Agent：用户客户端的一些必要信息，如UA头部等
         - 常用的响应头部
           - Access-Control-Allow-Headers: 服务器端允许的请求Headers
           - Access-Control-Allow-Methods: 服务器端允许的请求方法
           - Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）（跨域问题经常碰到）
           - Content-Type：服务端返回的实体内容的类型
           - Date：数据从服务器发送的时间
           - Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
           - Last-Modified：请求资源的最后修改时间
           - Expires：应该在什么时候认为文档已经过期,从而不再缓存它
           - Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
           - ETag：请求变量的实体标签的当前值
           - Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
           - Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
           - Server：服务器的一些相关信息
         - 一般来说，请求头部和响应头部是匹配分析的。

       - ##### 请求响应体 body

         - http请求时，除了头部，还有消息实体，一般来说

           请求实体中会将一些需要的参数都放入进入（用于post请求）。

           譬如实体中可以放参数的序列化形式（`a=1&b=2`这种），或者直接放表单对象（`Form Data`对象，上传时可以夹杂参数以及文件），等等

           而一般响应实体中，就是放服务端需要传给客户端的内容

           一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。

     - **get和Post的区别**

       - GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，如EditPosts.aspx?name=test1&id=123456.  POST方法是把提交的数据放在HTTP包的Body中.
       - GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.
       - GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
       - GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码

   - ##### 状态码

     - > 200——表明该请求被成功地完成，所请求的资源发送回客户端
       > 304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
       > 400——客户端请求有错（譬如可以是安全模块拦截）
       > 401——请求未经授权
       > 403——禁止访问（譬如可以是未登录时禁止）
       > 404——资源未找到
       > 500——服务器内部错误
       > 503——服务不可用

   - cookie

     - 在登陆页面，用户登陆了。此时，服务端会生成一个session，session中有对于用户的信息（如用户名、密码等）

       然后会有一个sessionid（相当于是服务端的这个session对应的key）

       然后服务端在登录页面中写入cookie，值就是:jsessionid=xxx

       然后浏览器本地就有这个cookie了，以后访问同域名下的页面时，自动带上cookie，自动检验，在有效时间内无需二次登陆。作者：dailc链接：https://juejin.im/post/5aa5cb846fb9a028e25d2fb1来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

3. ### 说说tcp  

   - TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。

   - > 术语TCP/IP代表传输控制协议/网际协议，指的是一系列协议。“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把**IP想像成一种高速公路**，它允许其它协议在上面行驶并找到到其它电脑的出口。**TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP**，文件传输协议FTP这样的协议等。

   - TCP提供有保证的数据传输，而UDP不提供

4. 对https了解吗  

5. 什么时候开始学前端，如何学习的  

6. 如何自主学习，解决问题，从项目中举一个例子，说明自己的学习能力  

7. 排序算法知道哪些，时间复杂度  

8. 前端主要做PC端还是移动端，我回答PC端，他说那你知道现在移动端流量更大嘛。。。一首凉凉送给自己。  

9. 了解hashmap吗？对其它后台语言有了解吗？  

10. 平时使用什么来控制版本？为什么使用svn？而不是git？  

11. 简历上写数据结构和算法有一定的基础，我感觉你写得不恰当。。。又一首凉凉送给自己。。。  

12. 平时除了做老师项目，还有没有什么其他的课外学习，学过哪些东西。。。